#!/bin/sh

# Test complex mixed git diff scenarios
# This test covers multiple git diff types in one patch file and edge cases

. ${top_srcdir-.}/tests/common.sh

# Create a complex patch with multiple git diff types:
# 1. New file with content
# 2. Deleted file
# 3. Binary file
# 4. Mode-only change
# 5. Pure rename (100% similarity)
# 6. Copy operation (< 100% similarity)
# 7. Regular content change
cat << EOF > complex-git.patch
diff --git a/new-file.txt b/new-file.txt
new file mode 100644
index 0000000..abcdef1
--- /dev/null
+++ b/new-file.txt
@@ -0,0 +1,2 @@
+This is a new file
+with some content
diff --git a/deleted-file.old b/deleted-file.old
deleted file mode 100644
index fedcba9..0000000
--- a/deleted-file.old
+++ /dev/null
@@ -1,2 +0,0 @@
-This file will be deleted
-goodbye
diff --git a/binary-data.bin b/binary-data.bin
new file mode 100644
index 0000000..1234567
Binary files /dev/null and b/binary-data.bin differ
diff --git a/script-mode.sh b/script-mode.sh
old mode 100644
new mode 100755
diff --git a/renamed-file.txt b/new-name.txt
similarity index 100%
rename from renamed-file.txt
rename to new-name.txt
diff --git a/copied-file.c b/copy-target.c
similarity index 85%
copy from copied-file.c
copy to copy-target.c
index abc123..def456 100644
--- a/copied-file.c
+++ b/copy-target.c
@@ -1,3 +1,4 @@
 #include <stdio.h>
 int main() {
+    printf("copied and modified\\n");
     return 0;
 }
diff --git a/regular-change.h b/regular-change.h
index 111222..333444 100644
--- a/regular-change.h
+++ b/regular-change.h
@@ -1,2 +1,2 @@
-#define OLD_VERSION 1
+#define NEW_VERSION 2
 /* header file */
EOF

# Test 1: lsdiff should list all files correctly
${LSDIFF} complex-git.patch 2>errors1 >result1 || exit 1
[ -s errors1 ] && exit 1

cat << EOF | cmp - result1 || exit 1
b/new-file.txt
a/deleted-file.old
a/binary-data.bin
a/script-mode.sh
b/new-name.txt
a/copied-file.c
a/regular-change.h
EOF

# Test 2: lsdiff with --git-prefixes=strip
${LSDIFF} --git-prefixes=strip complex-git.patch 2>errors2 >result2 || exit 1
[ -s errors2 ] && exit 1

cat << EOF | cmp - result2 || exit 1
new-file.txt
deleted-file.old
binary-data.bin
script-mode.sh
new-name.txt
copied-file.c
regular-change.h
EOF

# Test 3: Filter only new files
${FILTERDIFF} -i "*/*.txt" complex-git.patch 2>errors3 >result3 || exit 1
[ -s errors3 ] && exit 1

# Should include new-file.txt and new-name.txt (renamed file)
grep -q "new-file.txt" result3 || exit 1
grep -q "new-name.txt" result3 || exit 1
grep -q "binary-data.bin" result3 && exit 1  # Should not include binary

# Test 4: Filter binary files specifically
${FILTERDIFF} -i "*/*.bin" complex-git.patch 2>errors4 >result4 || exit 1
[ -s errors4 ] && exit 1

cat << EOF | cmp - result4 || exit 1
diff --git a/binary-data.bin b/binary-data.bin
new file mode 100644
index 0000000..1234567
Binary files /dev/null and b/binary-data.bin differ
EOF

# Test 5: Exclude deleted files
${FILTERDIFF} -x "*/*.old" complex-git.patch 2>errors5 >result5 || exit 1
[ -s errors5 ] && exit 1

# Should not contain deleted-file.old
grep -q "deleted-file.old" result5 && exit 1

# Test 6: Test grepdiff on content changes only
${GREPDIFF} "NEW_VERSION" complex-git.patch 2>errors6 >result6 || exit 1
[ -s errors6 ] && exit 1

# Should only match regular-change.h
grep -q "regular-change.h" result6 || exit 1
grep -q "new-file.txt" result6 && exit 1  # Should not match files without the pattern

# Test 7: Test with -p strip on complex paths
${FILTERDIFF} --git-prefixes=strip -p0 --strip=0 complex-git.patch 2>errors7 >result7 || exit 1
[ -s errors7 ] && exit 1

# Should preserve all content
grep -q "new-file.txt" result7 || exit 1
grep -q "binary-data.bin" result7 || exit 1

exit 0
